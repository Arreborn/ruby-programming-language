=========================================
Presentation
=========================================

Intro:
Redogör för vad SproutScript är,
vilken målgrupp språket är konstruerat för,
varför detta valdes,
designöverväganden för att nå upp till målet

1.
SproutScript är ett språk tänkt att vara ett mellanting som kombinerar de enklare aspekterna av Python och Ruby - dynamisk typning och enklare funktionsanrop - med den striktare syntax som är en god grund för framtida arbete i t.ex. Java och C-baserade språk. Språkets ambition är således att vara en enkel introduktion till grundläggande programmeringskoncept, som ger goda lärdomar och vanor som kan tas vidare till andra programmeringsspråk.

2.
Målgruppen för SproutScript är alltså nya programmerare utan någon förkunkap inom ämnet. Vidare så ser vi att vår målgrupp ska vara intresserade av fortsatt lärande inom programmering, så att den goda praxis som SproutScript erbjuder kan komma till nytta i fler programmeringsspråk.

3.
Denna målgrupp valdes då det kändes som en intressant avvägning kring vilka "enkla" aspekter som skulle behållas kontra de striktare aspekter som är nyttiga att lära sig. Att introducera en ny programmerare till t.ex. Python är inte strikt fel, men man missar exempelvis de nyttiga delarna såsom att definiera block med klammerparenteser samt att avsluta rader med semikolon. Dessa lärdomar är nyttiga att ta med sig om man i framtiden ska lära sig C-baserade språk, Java eller JavaScript.

Men för en nybörjare känns det enklare att lära sig de grundläggande koncepten om man har en enklare struktur att följa. Att lära sig att skriva en funktion kan vara enklare för vissa om de inte behöver bemöda sig med att hålla koll på returvariabelns typ, och att deklarera en variabel kan även vara enklare utan att i förväg besluta om dess typ. Att göra en utskrift till terminalen bör vara simpelt - det är enklare att konceptuellt förstå funktionen print(); i jämförelse med System.out.println(); i Java, eller Console.WriteLine(); i C#.

4.
Det krävdes således noga övervägande kring vilka aspekter vi ämnade att behålla, samt vilka vi valde att justera. Resultatet blev ett axplock av de bekvämaste aspekterna dynamiska språk som exempevis Python, och den striktare syntax som är vanlig i flera andra, välanvända programmeringsspråk.

Implementation:
SproutScript är byggt ovanpå Ruby, och består kortfattat av tre delar:
Parsning av användarskriven kod
Konstruktion av abstrakt syntax-träd utifrån användarskriven kod
Exekvering av syntax-trädet i körtid

För parsningen nyttjades den i kursen tillhandahållna parsern - rdparse.rb. Inga ändringar i denna parser har gjorts. Som bekant så kommer denna parser att ta in användarens text, nyttja sin lexer för att generera tokens utefter våra egendefinierade regler, och därefter matcha dessa tokens till våra egendefinierade regler i parsern.

När en regel i parsern matchar kommer det att genereras programnoder. Vi har två huvudsakliga typer av noder som genereras - exekverbara noder och datanoder. Gemensamt för samtliga noder är att de alla har en "run"-funktion, som vi använder för att köra samtliga noder.

# Visa kod för en datatyp, t.ex. integers
Datanoder är klasser vi har skapat för våra datatyper, såsom integers, strängar, booleans m.m. När en integer körs, exempelvis, så kommer denna att lämna över sitt värde i en form som Ruby kan tolka.

# Visa kod för variabeltilldelning och/eller Frames
En viktig exekverbar nod att tala om är variabeltilldelning. Varje exekverbar nod har tillgång till ett Frame-objekt, som är det scope som denna nod skapades med. I varje Frame-objekt finns dels en referens till det föregående scopet samt en hash som håller koll på samtliga variabler. En variabel kommer inte att läggas till i hashen under parsningen, utan när variabelnoden körs kommer nodens variabelnamn att tilldelas sitt värde i hashen.

# Visa kod för aritmetiknoder
Exekverbara noder är aningen mer intressanta. Dessa tar i regel emot antingen en ordinarie Ruby-sträng (som representerar ett variabelnamn) eller en av våra egenskrivna datatyper för att utföra en operation på dem. Aritmetiska noder är ett utmärkt exempel att tala om. Dessa tar en in ett vänsterled och ett högerled. Under exekvering kommer de endast att köra vänster- respektive höger-led tills att den har ett värde för vardera led som Ruby kan tolka. Därefter används send-metoden tillsammans med korrekt operator för att ge det nya värdet. Detta värde skapar därefter en ny SproutScript-datatyp som kan användas i nästa steg.

# Visa AST
Tack vare detta är det enkelt att nästla dessa noder. En variabel kan vid tilldelning ha en aritmetisk nod som sitt värde. Denna aritmetiska nod kan i sin tur ha en aritmetisk nod som sitt högerled och sitt vänsterled, och så vidare. Eftersom körningen för dessa noder kommer alltid den vänstra delen av en aritmetisk nod att utvärderas först, och underliggande aritmetiska noder kommer likväl också att utvärderas på samma sätt. Resultatet blir en slutgiltig SproutScript-datatyp som kan läggas till i scopets hash-tabell för variabler.

# Körtid
Alla exekverbara noder kommer att läggas till i parserns syntax-träd. De hamnar alltså i kronologisk ordning utefter när i användarens kod de skrevs. När programmet sedan ska köras så kör man parserns egna "run"-funktion, som kommer att iterera genom samtliga noder i syntax-trädet i ordning, och exekvera varje nods individuella "run"-funktion.

# Visa do-while loop
Samma princip har implementerats för styrstrukturer och loopar. När parsern upptäcker att en styrstruktur eller loop skapas, så kommer ett nytt Frame-objekt att skapas (då vi går in i ett nytt scope), och ett nytt syntax-träd genereras och lagras i en klassvariabel. Eftersom parsern alltid lägger till en exekverbar nod i det syntax-träd som för närvarande är i klassvariabeln så kommer alla noder som tillhör dessa strukturer att läggas i detta nya syntax-träd. Därefter så kan en styrstruktur eller loop, om villkoret är uppfyllt, enkelt iterera genom alla sina noder och köra "run" på dessa.

# Visa funktionsdefinition
Funktioner fungerar på ett snarlikt sätt, ungefär som en kombination av variabeltilldelning och en styrstruktur. En SproutUserFunction-nod kommer att ha ett isolerat scope, där endast de variabler som tilldelas inuti detta scope syns. Alla noder som ska exekveras när denna funktion körs lagras i funktionens syntax-träd. Denna användardefinierade funktion lagras därefter i en hash-tabell för alla tillgängliga funktioner i det globala scopet (eller det första scopet).

Att kalla på en funktion genererar även detta en exekverbar nod, som tar emot alla eventuella parametrar. Funktionskallet kommer då att hämta den relevanta funktionen från korrekt hash-tabell, skicka med de parametrar som är noterade i funktionsanropet till användarfunktionen, och köra "run" på användarfunktionen.

# Några intressanta noder
Vi ville även implementera lite övrig funktionalitet som var användbar. Funktioner för utskrift, användarinmatning och kontroll av en variabels klass har implementerats som exekverbara noder. Vidare, så har även en dedikerad test-funktion implementerats, med inspiration från Rubys unit:test. I dessa test-noder kan en användare mata in något värde, exempelvis en variabel eller ett funktionskall, och jämföra det med ett annat värde. En sammanställning av alla genomförda tester och deras utfall skrivs ut efter att all programkod exekverats.

En annan intressant funktionalitet vi har implementerat är egenskrivna felmeddelanden. Vi har, i den mån det är möjligt, försökt att plocka bort alla felmeddelanden och stack-traces som Ruby skriver ut. Detta gjordes för att det inte ska upplevas från användaren som att de arbetar i Ruby, utan det ska tydligt kännas som att SproutScript är sitt eget avgränsade språk. Ambitionen var att även implementera egna stacktraces, men detta visade sig vara alldeles för komplext att implementera vid den punkt vi satte igång med det - så denna funktionalitet föll bort.

Utmaningar:
Under projektets gång har vi stött på ett antal utmaningar, dock inte något oöverkomligt. Vi har även identifierat ett antal brister i fundamentala delar av vår programkod som det i detta skede inte finns tid att ändra på.

Två markanta utmaningar vi stötte på berörde nästlade loopar samt funktioner med rekursion.

När vi började arbeta med nästlade loopar hade vi problem med att se till att rätt iteration av loopen kördes, och att upprepningen skedde så många gånger som koden krävde. Problemet som vi upptäckte i slutändan var hur vi lagrade klassvariabler i våra exekverbara noder - t.ex. i jämförelsenoder och aritmetiska noder. Vid första körningen av en jämförelsenod så var klassvariabeln @lhs tilldelad en egen aritmetisk nod, till exempel. Vid körning av jämförelsenoden så nyttjades "run"-funktionen på den aritmetiska noden, och resultatet av denna skrevs över till klassvariabeln @lhs. Detta innebar rent praktiskt att uträkningar och jämförelser endast gjordes en gång, och värdet på dessa sparades sedan undan permanent. Det tog en del undersökning för att hitta denna problematik, men det var en nyttig justering att göra.

Det andra stora problemet berörde funktioners returvärde, och medan funktionalitet för detta finns så fungerar det inte som önskat. Detta beror även på den felaktiga konstruktion som var för djupt rotad i programkoden för att kunna justeras. Så som våra scopes skickas genom programmet, så har det resulterat i att en funktion som innehåller styrstrukturer inte kan ha ett returvärde inuti styrstrukturen. En ren begränsning blir att dessa retur-noder, vars syfte är att returnera ett värde omedelbart och bryta resten av exekveringen av koden, inte kan ligga nästlade i styrstrukturer. De kan inte se korrekt scope, och när de ligger nästlade så kommer de inte att hitta det värde de ska skicka tillbaka, och värdet blir NilClass. Vi har en tanke om hur detta skulle kunna lösas, men det är tveksamt om det finns tid att göra de djupgående ändringar som krävs för att fixa denna bugg.

Avslutning:
Allt som allt så var målet att skapa ett språk med en tydligt stoppunkt - där användarens nuvunna kunskap från att ha arbetat i SproutScript kan översättas till ett annat programmeringsspråk. Genom att skriva enklare program i SproutScript kommer användaren att ha en god grund att stå på, och en lägre inlärningskurva när denne arbetar med t.ex. C# eller Java.
